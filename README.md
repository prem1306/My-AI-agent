# My-AI-agent
A hybrid AI assistant merging web intelligence with desktop control. It instantly explains online text and executes local commands like opening apps. Built for seamless productivity, the system scales easily to support future capabilities like voice control, long-term memory, and new autonomous agents.
Local AI Agent Framework: Comprehensive Project Report Project Inception and Vision The Local AI Agent Framework was conceived to solve a fundamental disconnect in modern computing: the separation between cloud-based intelligence and local system control. While Large Language Models (LLMs) offer immense reasoning capabilities, they are typically trapped in browser tabs, unable to interact with the user's actual computer. Conversely, local scripts can control the computer but lack intelligence. This project bridges that gap by creating a Hybrid Agent Architecture that lives in the browser but has secure reach into the local operating system.

Technical Architecture The system is built on a robust client-server model designed for low latency and high modularity:

Backend (The Core): A local Python server built with FastAPI acts as the central nervous system. It runs on localhost:8000 and serves as the orchestration layer, managing agent registration, task routing, and inter-process communication (IPC). Frontend (The Interface): A custom Chrome Extension serves as the user interface. It injects content scripts into web pages to capture user intent (keystrokes, text selection) and communicates with the backend via HTTP requests. Persistence Layer: A SQLite database (history.db) provides long-term memory, logging every interaction, command, and explanation for auditability and context retrieval. The Hybrid Agent Model The framework's power lies in its ability to orchestrate two distinct types of agents simultaneously:

The Main Agent (Offline Controller)
Purpose: To execute deterministic, secure system operations without internet reliance. Technology: Built on a custom Offline Parser (Regex/Keyword based) and a secure SystemTools library. Functionality: It listens for commands via a terminal-style overlay (Ctrl+Shift+Q). Users can launch applications (Notepad, Calculator), manage file structures (create/delete folders), and execute shell commands. Security: Crucially, this agent operates within a strict Sandbox. It uses a

SecurityManager to enforce path validation (preventing directory traversal) and command whitelisting, ensuring the AI cannot accidentally harm the host system.

The Google Explainer Sub-Agent (Online Analyst)

Purpose: To provide semantic understanding and context-aware assistance. Technology: Integrated using the Google Generative AI SDK (Google ADK) and powered by the Gemini 2.0 Flash model. Functionality: Triggered by Shift+E, it captures highlighted text from the browser, sends it to the backend, and uses Gemini to generate simplified explanations. These are rendered in a modern, non-intrusive popup overlay directly on the webpage. Development Journey The project evolved through several critical phases:

Foundation: We established the AgentRegistry and TaskRouter patterns in Python, allowing for dynamic agent registration. Integration: We built the FastAPI server to expose these agents to the Chrome Extension. UI/UX: We moved away from simple alerts to rich, HTML/CSS overlays for a premium user experience. Refinement: We implemented a unified History feature, requiring database integration and frontend updates to visualize past interactions. Debugging: We solved critical issues around blocking processes (switching to non-blocking subprocess.Popen) and error handling to ensure a smooth, crash-free experience.

Use Cases Productivity: A developer can open their coding environment, create project folders, and launch documentation without ever leaving their browser. Research: Students can instantly clarify complex academic text on any website without breaking their reading flow. System Management: Users can perform quick PC maintenance tasks via natural language commands. Future Scalability: The architecture is explicitly designed for growth. The Agent Registry pattern allows developers to "plug in" new sub-agents with minimal friction. Future expansions could include:

Voice Agent: Integrating pyttsx3 and speech_recognition for hands-free control. Code Analyst: A sub-agent dedicated to explaining code snippets on GitHub. Memory Agent: A vector-database powered agent that "remembers" user preferences across sessions. This framework demonstrates that by combining the deterministic reliability of local code with the probabilistic power of LLMs, we can create truly agentic systems that are both safe and incredibly powerful.
